from boofuzz import *
import sys
import json
from binascii import *
import logging
import time
from struct import *

ITEM_MUTATE_COUNT = 5


def _mutate_bytes(v):
	tag = 'mutate_bytes'
	s_initialize(tag)
	if len(v) == 1:
		s_byte(value=ord(v))
	elif len(v)==2:
		s_word(value=int(b2a_hex(v),16))
	elif len(v)==3:
		s_random(value=v,min_length=0,max_length=len(v)+2)
	elif len(v)==4:
		s_dword(value=int(b2a_hex(v),16))
	else:
		logging.debug('Error in _mutate_bytes:{}'.format(len(v)))

	data = s_get(tag)
	blocks.REQUESTS={}
	return data


def _mutate_str(v,max_length=0x1060):
	tag = 'mutate_str'
	s_initialize(tag)
	s_string(value=v,max_len=max_length)

	data = s_get(tag)

	blocks.REQUESTS={}
	return data


def _mutate_binary(v):
	tag = 'mutate_binary'

	s_initialize(tag)
	s_random(value=v,min_length=0,max_length=len(v))

	data = s_get(tag)
	blocks.REQUESTS={}
	return data


def mutate(field): ## field = (type,value) such as ('number','\x03')
	if field[0] == 'number':
		# print('in mutate',field)
		ret = _mutate_bytes(field[1])
	elif field[0] == 'str':
		ret = _mutate_str(field[1])
	else:
		ret = _mutate_binary(field[1])
	return ret


def gendata(idx, dataModel):
	field = dataModel[idx]
	# logging.debug(field)
	mutate_field_array = mutate(field)
	# print(mutate_field_array)
	result = []
	for mutateItem in mutate_field_array:
		composed = [] # composed mutate dataItem, which can be sent to target
		for i in range(0,len(dataModel)):
			if i == idx:
				# FIXME: add length constraint for string mutation
				composed.append(mutateItem)
			else:
				composed.append(dataModel[i][1]) # dataModel[i] is a field, which is organized as (type, data)

		result.append(''.join(composed))
	return result


# only for protocol of gxworks_2 
# different protocol will have different encode method

def encode(data): # complete constraint in datastream and between communication
	length = len(data)
	if length>=21:
		bin_data = pack('H',(length-21))
	else:
		bin_data = '\x00\x00'
	return data[:19]+bin_data+data[21:]

def mutateDataItem(dataModel):
	new_dataModel = []
	mutate_array = []
	for model in dataModel: #field
		t = model[0]
		v = a2b_hex(model[1])
		new_dataModel.append((t,v))

	field_count = len(new_dataModel)
	for i in range(0,field_count):
		data_list = gendata(i,new_dataModel)
		for d in data_list:
			mutate_array.append(encode(d))
	return mutate_array


def _build_mutateModel(idx,dataModel,inner_business_dict):
	if idx in inner_business_dict.keys():
		return None
	
	seed_array = []
	for model in dataModel:
		# t = model[0] # type
		# v = a2b_hex(model[1]) # origin data
		
		mutate_seed = mutate(model)
		seed_array.append(mutate_seed)
	inner_business_dict[idx] = seed_array
	return None

def _get_mutate_data(seed):
	result = []
	count = 0
	while seed.mutate():
		data = seed.render()
		result.append(data)
		count +=1
		if count == 1:
			break

	return result

"""
given a specific dataModel, mutate one field defined by idx, get the mutate data of the field
idx : field idx of dataModel
dataModel: generated by the packet
seed : corresponding to the field 
"""	

def _gen_data_from_field(idx, dataModel, seed):
	field = dataModel[idx]
	mutate_field_array = _get_mutate_data(seed)
	result = []
	if len(mutate_field_array) != 0:
		for mutateItem in mutate_field_array:
			composed = []
			for i in range(0,len(dataModel)):
				if i==idx:
					composed.append(mutateItem)
				else:
					# print(dataModel[i][1])
					composed.append(dataModel[i][1]) # dataModel[i] is a field, which is organized as (type, data)
			# print(composed)
			result.append(''.join(composed))
	return result


"""
idx: the sequence of datastreams 
inner_business_dict: store seeds of corresponding dataModel
dataModel: specific fields+ of a packet,each field is like (type,value) 
"""

def get_data_list(idx,inner_business_dict,dataModel): # should build mutateModel first
	idx = int(idx)
	if idx not in inner_business_dict.keys():
		print('index : {}'.format(idx))
		print('keys:{}'.format(inner_business_dict.keys()))
		logging.debug('have not built the dataModel')
		sys.exit(0)
	mutate_seeds = inner_business_dict[idx]
	result = []
	model =  dataModel[int(idx)]
	for i in range(len(mutate_seeds)):
		seed = mutate_seeds[i]
		data_list = _gen_data_from_field(i,model,seed)
		if len(data_list) !=0:
			result += data_list
	return result


def global_test():
	global_business_dict = {}
	filename = './template/test_connect.json'

	global_business_dict[filename] = {}

# build according to need

def build_business_model(filename):
	m_dict = json.loads(open(filename,'r').read()) # dataModel
	keys = sorted([int(k) for k in list(m_dict.keys())])
	inner_seed_dict = {}
	inner_model = []
	for k in keys: #all keys
		dataModel = [(item[0],a2b_hex(item[1])) for item in m_dict[str(k)]]
		_build_mutateModel(k,dataModel,inner_seed_dict)
		# inner_model_dict[k] = dataModel
		inner_model.append(dataModel)

	return (inner_seed_dict,inner_model)

def test_model_bak():
	filename = './template/test_connect.json'
	model = build_business_model(filename)
	start = time.time()
	# state = [str(item) for item in range(0,len(model[1]))]
	state = ["0"]
	data_count  = 0
	print(state)
	# sys.exit(1)
	iteration_cnt = 0
	while True:
		iteration_cnt += 1
		for s in state:
			dataList = get_data_list(s,model[0],model[1]) 

			if len(dataList)==0:
				print('dataList is 0')
				logging.debug(data_count)
				sys.exit(0)
				break
			for d in dataList:
				data_count += 1
				# if len(d) >= 4160:
				# 	logging.debug('data:{}'.format(b2a_hex(encode(d))))
				# 	logging.debug(data_count)
				# 	sys.exit(0)
				logging.debug("length:{}".format(len(d)))
				
				# print(b2a_hex(encode(d)))
		# print('data_count:{}'.format(data_count))
		if data_count == 50000 or iteration_cnt>=50000:
			break
	
	end = time.time()
	print('consume:{}'.format(end-start))

def test_model():
	filename = './template/test_connect.json'
	model = build_business_model(filename)
	start = time.time()
	state = [str(item) for item in range(0,len(model[1]))]
	data_count  = 0
	print(state)
	# sys.exit(1)
	while True:
		for s in state:
			if s =="1":
				# continue
				# logging.debug("is 1")
				dataList = get_data_list(s,model[0],model[1]) 
				for item in dataList:
					logging.debug(len(item))

				if len(dataList)==0:
					print('dataList is 0')
					logging.debug(data_count)
					sys.exit(0)
					break
				for d in dataList:
					data_count += 1
					if data_count == 255:
						sys.exit(0)
				# print(b2a_hex(encode(d)))
		# print('data_count:{}'.format(data_count))
		if data_count == 50000:
			break
	
	end = time.time()
	print('consume:{}'.format(end-start))


def build_business(filename,inner_business_dict):
	# filename = './template/business_connect_close.json'
	m_dict = json.loads(open(filename,'r').read()) # a total inner buiness
	# inner_business_dict = {}

	keys = sorted(list(m_dict.keys()))
	count = 0

	for k in keys: # key corresponding to state
		dataModel = m_dict[k]
		new_dataModel = []
		for model in dataModel:
			t = model[0]
			v = a2b_hex(model[1])
			new_dataModel.append((t,v))
		_build_mutateModel(k,new_dataModel,inner_business_dict)
		data_list = get_data_list(k,inner_business_dict,new_dataModel) # this function is the center
		# for data in data_list:
		# 	print(b2a_hex(data))
		# data_list = get_data_list(k,inner_business_dict,new_dataModel)
		for data in data_list:
			print(b2a_hex(data))
		count += 1
		if count==5:
			break
		
	
def main():
	filename = './template/test_connect.json'
	filename = './template/read_from_plc.json'
	m_dict = json.loads(open(filename,'r').read())
	# print(m_dict)
	t_start = time.time()
	keys = sorted(list(m_dict.keys()))
	mutate_array = []
	count = 0
	for k in keys:
		count += 1
		# print(k)
		dataModel = m_dict[k]
		new_dataModel = []
		for model in dataModel:
			t = model[0]
			v = a2b_hex(model[1])
			new_dataModel.append((t,v))
		# logging.debug('field in dataModel:{}'.format(len(dataModel)))
		length = len(dataModel)
		for i in range(0,length):
			data_list = gendata(i,new_dataModel)
			for d in data_list:
				mutate_array.append(d)
				print(b2a_hex(encode(d)))

		if count==3:
			break
		# break
	print(len(mutate_array))
	t_end = time.time()
	print(t_end-t_start)
	

if __name__ == '__main__':
	logging.basicConfig(level=logging.DEBUG)
	# main()
	# test_model()
	test_model_bak()